// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel Main
#pragma kernel ClearUnused
#include "MarchTables.compute"

// In
StructuredBuffer<float2> points;    //iso, matID
int numPointsPerAxis;
float surfaceLevel;
uint maxTriangles;
// Out
struct TriData
{
    float3 pos0;
    float3 norm0;
    float2 uv0;

    float3 pos1;
    float3 norm1;
    float2 uv1;

    float3 pos2;
    float3 norm2;
    float2 uv2;
};
RWByteAddressBuffer vertBuffer;
RWByteAddressBuffer indexBuffer;

// Used for counting triangles
RWStructuredBuffer<uint> triCounter;


struct CubeVertex
{
    float x;
    float y;
    float z;
    float iso;
    float materialID;
};


#define SIZEOF_FLOAT3 12
#define SIZEOF_FLOAT2 8
#define SIZEOF_UINT 4

void writeTri(uint index, TriData data)
{
    // Get the count to find where in the buffer to store this triangle
    index *= 3;

    indexBuffer.Store3(index * SIZEOF_UINT, uint3(index, index + 1, index + 2));

    uint vertAddr = index * (SIZEOF_FLOAT3 * 2 + SIZEOF_FLOAT2);
    vertBuffer.Store3(vertAddr, asuint(data.pos0));
    vertBuffer.Store3(vertAddr + SIZEOF_FLOAT3, asuint(data.norm0));
    vertBuffer.Store2(vertAddr + SIZEOF_FLOAT3 * 2, asuint(data.uv0));

    vertAddr += SIZEOF_FLOAT3 * 2 + SIZEOF_FLOAT2;
    vertBuffer.Store3(vertAddr, asuint(data.pos1));
    vertBuffer.Store3(vertAddr + SIZEOF_FLOAT3, asuint(data.norm1));
    vertBuffer.Store2(vertAddr + SIZEOF_FLOAT3 * 2, asuint(data.uv1));

    vertAddr += SIZEOF_FLOAT3 * 2 + SIZEOF_FLOAT2;
    vertBuffer.Store3(vertAddr, asuint(data.pos2));
    vertBuffer.Store3(vertAddr + SIZEOF_FLOAT3, asuint(data.norm2));
    vertBuffer.Store2(vertAddr + SIZEOF_FLOAT3 * 2, asuint(data.uv2));
}




CubeVertex getCubeVertex(int x, int y, int z)
{
    CubeVertex res;
    res.x = x;
    res.y = y;
    res.z = z;
    res.iso = points[(x * numPointsPerAxis + y) * numPointsPerAxis + z].x;
    res.materialID = points[(x * numPointsPerAxis + y) * numPointsPerAxis + z].y;
    return res;
}

float3 lerpEdge(CubeVertex v0, CubeVertex v1)
{
    float t = (surfaceLevel - v0.iso) / (v1.iso - v0.iso);
    float3 res;
    res.x = v0.x + (v1.x - v0.x) * t;
    res.y = v0.y + (v1.y - v0.y) * t;
    res.z = v0.z + (v1.z - v0.z) * t;
    return res;
}

[numthreads(8,8,8)]
void Main(uint3 id : SV_DispatchThreadID)
{
    if (id.x >= numPointsPerAxis - 1 || id.y >= numPointsPerAxis - 1 || id.z >= numPointsPerAxis - 1)
    {
        return;
    }

    CubeVertex voxel[8] =
    {
        getCubeVertex(id.x, id.y, id.z),
        getCubeVertex(id.x + 1, id.y, id.z),
        getCubeVertex(id.x + 1, id.y, id.z + 1),
        getCubeVertex(id.x, id.y, id.z + 1),
        getCubeVertex(id.x, id.y + 1, id.z),
        getCubeVertex(id.x + 1, id.y + 1, id.z),
        getCubeVertex(id.x + 1, id.y + 1, id.z + 1),
        getCubeVertex(id.x, id.y + 1, id.z + 1)
    };

    // Check each point is valid. this could be improved
    for (int i = 0; i < 8; i++)
    {
        if (voxel[i].materialID == -1)
        {
            return;
        }
    }

    int cubeIndex = 0;
    if (voxel[0].iso <= surfaceLevel) cubeIndex |= 1;
    if (voxel[1].iso <= surfaceLevel) cubeIndex |= 2;
    if (voxel[2].iso <= surfaceLevel) cubeIndex |= 4;
    if (voxel[3].iso <= surfaceLevel) cubeIndex |= 8;
    if (voxel[4].iso <= surfaceLevel) cubeIndex |= 16;
    if (voxel[5].iso <= surfaceLevel) cubeIndex |= 32;
    if (voxel[6].iso <= surfaceLevel) cubeIndex |= 64;
    if (voxel[7].iso <= surfaceLevel) cubeIndex |= 128;

    if (cubeIndex == 0 || cubeIndex == 255)
    {
        return;
    }

    TriData tri;
    for (int j = 0; triangleTable[cubeIndex][j] != -1; j += 3)
    {
        int a0 = edgeConnection[triangleTable[cubeIndex][j+2]][0];
        int b0 = edgeConnection[triangleTable[cubeIndex][j+2]][1];
        int a1 = edgeConnection[triangleTable[cubeIndex][j+1]][0];
        int b1 = edgeConnection[triangleTable[cubeIndex][j+1]][1];
        int a2 = edgeConnection[triangleTable[cubeIndex][j]][0];
        int b2 = edgeConnection[triangleTable[cubeIndex][j]][1];

        tri.pos0 = lerpEdge(voxel[a0], voxel[b0]);
        tri.pos1 = lerpEdge(voxel[a1], voxel[b1]);
        tri.pos2 = lerpEdge(voxel[a2], voxel[b2]);

        float3 p0 = tri.pos1 - tri.pos0;
        float3 p1 = tri.pos2 - tri.pos0;
        float3 normal;
        normal.x = (p0.y * p1.z - p1.y * p0.z);
        normal.y = (p0.x * p1.z - p1.x * p0.z) * -1;
        normal.z = (p0.x * p1.y - p1.x * p0.y);

        tri.norm0 = normal;
        tri.norm1 = normal;
        tri.norm2 = normal;

        tri.uv0 = max(voxel[a0].materialID, voxel[b0].materialID), 0;
        tri.uv1 = max(voxel[a1].materialID, voxel[b1].materialID), 0;
        tri.uv2 = max(voxel[a2].materialID, voxel[b2].materialID), 0;

        //vertBuffer.Append(tri);
        uint count = triCounter.IncrementCounter();
        if (count >= maxTriangles) return;
        writeTri(count, tri);
    }
}


[numthreads(64, 1, 1)]
void ClearUnused(uint id : SV_DispatchThreadID)
{
    TriData data;
    data.pos0 = 0;
    data.pos1 = 0;
    data.pos2 = 0;
    data.norm0 = 0;
    data.norm1 = 0;
    data.norm2 = 0;
    data.uv0 = 0;
    data.uv1 = 0;
    data.uv2 = 0;

    while (true)
    {
        uint count = triCounter.IncrementCounter();
        if (count >= maxTriangles) break;
        //uint vidx = count * 3;
        //WriteVertex(vidx + 0, 0, 0);
        //WriteVertex(vidx + 1, 0, 0);
        //WriteVertex(vidx + 2, 0, 0);
        //WriteIndices(vidx, uint3(0, 0, 0));

        writeTri(count, data);
    }
}